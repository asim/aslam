{{define "chat.html"}}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>{{.Conversation.Title}} - Aslam</title>
    {{template "style"}}
    <style>
        .typing { opacity: 0.6; }
        .typing .message-content::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown { line-height: 1.5; }
        .markdown > *:first-child { margin-top: 0; }
        .markdown > *:last-child { margin-bottom: 0; }
        .markdown h1, .markdown h2, .markdown h3 { margin: 0.5em 0 0.2em 0; font-weight: 600; }
        .markdown h1 { font-size: 1.15em; }
        .markdown h2 { font-size: 1.05em; }
        .markdown h3 { font-size: 1em; }
        .markdown p { margin: 0.5em 0; }
        .markdown ul, .markdown ol { margin: 0.2em 0; padding-left: 1.4em; }
        .markdown li { margin: 0; padding: 0; border: none; }
        .markdown li > ul, .markdown li > ol { margin: 0; }
        .markdown code { background: #f4f4f4; padding: 1px 4px; border-radius: 3px; font-size: 0.9em; }
        .markdown pre { background: #f4f4f4; padding: 8px; border-radius: 4px; overflow-x: auto; margin: 0.3em 0; }
        .markdown pre code { background: none; padding: 0; }
        .markdown blockquote { border-left: 2px solid #ddd; padding-left: 8px; margin: 0.3em 0; color: #666; }
        .markdown a { color: #0066cc; }
        .markdown strong { font-weight: 600; }
        .markdown hr { border: none; border-top: 1px solid #ddd; margin: 0.5em 0; }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>ASLAM</h1>
            <nav>
                <a href="/">home</a>
                <a href="/chat">chats</a>
                <a href="/search">search</a>
            </nav>
        </header>
        
        <main class="app-content" id="messages">
            <h2 id="chat-title">{{.Conversation.Title}}</h2>
            
            {{if .Messages}}
            {{range .Messages}}
            <div class="message {{.Role}}">
                <div class="message-role">{{.Role}} <span class="time">{{formatTime .CreatedAt}}</span></div>
                <div class="message-content{{if eq .Role "assistant"}} markdown{{end}}">{{.Content}}</div>
            </div>
            {{end}}
            {{else}}
            <p class="muted" id="empty-state">Start the conversation below.</p>
            {{end}}
        </main>

        <footer class="app-footer">
            <form id="chat-form">
                <input type="hidden" name="conversation_id" value="{{.Conversation.ID}}">
                <textarea name="message" id="message-input" placeholder="Type your message..." autofocus></textarea>
                <button type="submit" id="send-btn">Send</button>
            </form>
        </footer>
    </div>

    <script>
        const form = document.getElementById('chat-form');
        const msgInput = document.getElementById('message-input');
        const messages = document.getElementById('messages');
        const sendBtn = document.getElementById('send-btn');
        const convId = form.querySelector('input[name="conversation_id"]').value;

        function formatTime() {
            const now = new Date();
            return now.toISOString().slice(0, 16).replace('T', ' ');
        }

        function addMessage(role, content, isTyping = false) {
            const empty = document.getElementById('empty-state');
            if (empty) empty.remove();

            const div = document.createElement('div');
            div.className = 'message ' + role + (isTyping ? ' typing' : '');
            div.innerHTML = `
                <div class="message-role">${role} <span class="time">${formatTime()}</span></div>
                <div class="message-content${role === 'assistant' ? ' markdown' : ''}">${escapeHtml(content)}</div>
            `;
            messages.appendChild(div);
            scrollToBottom();
            // Render markdown in new message
            const md = div.querySelector('.markdown');
            if (md && typeof marked !== 'undefined') {
                md.innerHTML = marked.parse(md.textContent);
                md.dataset.rendered = 'true';
            }
            return div;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function scrollToBottom() {
            messages.scrollTop = messages.scrollHeight;
        }

        function updateTitle(title) {
            const titleEl = document.getElementById('chat-title');
            if (titleEl.textContent === 'New conversation') {
                titleEl.textContent = title.length > 50 ? title.slice(0, 50) + '...' : title;
            }
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const message = msgInput.value.trim();
            if (!message) return;

            msgInput.disabled = true;
            sendBtn.disabled = true;
            msgInput.value = '';
            msgInput.style.height = 'auto';

            addMessage('user', message);
            updateTitle(message);

            const typingDiv = addMessage('assistant', 'Processing', true);

            try {
                const resp = await fetch('/api/chat/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation_id: parseInt(convId), message: message })
                });

                const data = await resp.json();
                typingDiv.remove();
                
                if (data.error) {
                    addMessage('assistant', 'Error: ' + data.error);
                } else {
                    addMessage('assistant', data.response);
                }
            } catch (err) {
                typingDiv.remove();
                addMessage('assistant', 'Error: ' + err.message);
            }

            msgInput.disabled = false;
            sendBtn.disabled = false;
            msgInput.focus();
        });

        // Auto-grow textarea
        msgInput.addEventListener('input', () => {
            msgInput.style.height = 'auto';
            msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
        });

        // Submit on Enter (Shift+Enter for newline)
        msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                form.dispatchEvent(new Event('submit'));
            }
        });

        // Scroll to bottom on load
        scrollToBottom();

        // Render markdown
        function renderMarkdown() {
            document.querySelectorAll('.markdown').forEach(el => {
                if (!el.dataset.rendered) {
                    el.innerHTML = marked.parse(el.textContent);
                    // Remove <p> wrappers inside <li> to reduce whitespace
                    el.querySelectorAll('li > p:first-child').forEach(p => {
                        p.replaceWith(...p.childNodes);
                    });
                    el.dataset.rendered = 'true';
                }
            });
        }
        renderMarkdown();
    </script>
</body>
</html>
{{end}}
