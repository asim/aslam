{{define "chat.html"}}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>{{.Conversation.Title}} - Aslam</title>
    {{template "style"}}
    <style>
        .typing { opacity: 0.6; }
        .typing .message-content::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown { line-height: 1.5; }
        .markdown > *:first-child { margin-top: 0; }
        .markdown > *:last-child { margin-bottom: 0; }
        .markdown h1, .markdown h2, .markdown h3 { margin: 0.5em 0 0.2em 0; font-weight: 600; }
        .markdown h1 { font-size: 1.15em; }
        .markdown h2 { font-size: 1.05em; }
        .markdown h3 { font-size: 1em; }
        .markdown p { margin: 0.5em 0; }
        .markdown ul, .markdown ol { margin: 0.2em 0; padding-left: 1.4em; }
        .markdown li { margin: 0; padding: 0; border: none; }
        .markdown li > ul, .markdown li > ol { margin: 0; }
        .markdown code { background: #f4f4f4; padding: 1px 4px; border-radius: 3px; font-size: 0.9em; }
        .markdown pre { background: #f4f4f4; padding: 8px; border-radius: 4px; overflow-x: auto; margin: 0.3em 0; }
        .markdown pre code { background: none; padding: 0; }
        .markdown blockquote { border-left: 2px solid #ddd; padding-left: 8px; margin: 0.3em 0; color: #666; }
        .markdown a { color: #0066cc; }
        .markdown strong { font-weight: 600; }
        .markdown hr { border: none; border-top: 1px solid #ddd; margin: 0.5em 0; }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1><a href="/" style="text-decoration:none;color:inherit">Aslam</a></h1>
            <nav>
                <a href="/">home</a>
                <a href="/chat">chats</a>
                <a href="/search">search</a>
                <a href="/dev">dev</a>
            </nav>
        </header>
        
        <main class="app-content" id="messages">
            <h2 id="chat-title">{{.Conversation.Title}}</h2>
            
            {{if .Messages}}
            {{range .Messages}}
            <div class="message {{.Role}}">
                <div class="message-role">{{if eq .Role "user"}}{{$.UserName}}{{else}}Assistant{{end}} <span class="time" data-time="{{.CreatedAt.Unix}}">{{formatTime .CreatedAt}}</span></div>
                <div class="message-content{{if eq .Role "assistant"}} markdown{{end}}">{{.Content}}</div>
            </div>
            {{end}}
            {{else}}
            <p class="muted" id="empty-state">Start the conversation below.</p>
            {{end}}
        </main>

        <footer class="app-footer">
            <form id="chat-form">
                <input type="hidden" name="conversation_id" value="{{.Conversation.ID}}">
                <textarea name="message" id="message-input" placeholder="Type your message..." autofocus></textarea>
                <button type="button" id="mic-btn" title="Voice input">ðŸŽ¤</button>
                <button type="submit" id="send-btn">Send</button>
            </form>
        </footer>
    </div>

    <script>
        const form = document.getElementById('chat-form');
        const msgInput = document.getElementById('message-input');
        const messages = document.getElementById('messages');
        const sendBtn = document.getElementById('send-btn');
        const convId = form.querySelector('input[name="conversation_id"]').value;

        const userName = '{{.UserName}}';
        
        function timeAgo(date) {
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return minutes + 'm ago';
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return hours + 'h ago';
            const days = Math.floor(hours / 24);
            if (days < 7) return days + 'd ago';
            return date.toLocaleDateString();
        }
        
        function updateTimeAgo() {
            document.querySelectorAll('.time[data-time]').forEach(el => {
                const ts = parseInt(el.dataset.time) * 1000;
                el.textContent = timeAgo(new Date(ts));
            });
        }
        updateTimeAgo();
        setInterval(updateTimeAgo, 60000);

        function addMessage(role, content, isTyping = false) {
            const empty = document.getElementById('empty-state');
            if (empty) empty.remove();

            const div = document.createElement('div');
            div.className = 'message ' + role + (isTyping ? ' typing' : '');
            div.innerHTML = `
                <div class="message-role">${role === 'user' ? userName : 'Assistant'} <span class="time">just now</span></div>
                <div class="message-content${role === 'assistant' ? ' markdown' : ''}">${escapeHtml(content)}</div>
            `;
            messages.appendChild(div);
            scrollToBottom();
            // Render markdown in new message
            const md = div.querySelector('.markdown');
            if (md && typeof marked !== 'undefined') {
                md.innerHTML = marked.parse(md.textContent);
                md.dataset.rendered = 'true';
            }
            return div;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function scrollToBottom() {
            messages.scrollTop = messages.scrollHeight;
        }

        function updateTitle(title) {
            const titleEl = document.getElementById('chat-title');
            if (titleEl.textContent === 'New conversation') {
                titleEl.textContent = title.length > 50 ? title.slice(0, 50) + '...' : title;
            }
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const message = msgInput.value.trim();
            if (!message) return;

            msgInput.disabled = true;
            sendBtn.disabled = true;
            msgInput.value = '';
            msgInput.style.height = 'auto';

            addMessage('user', message);
            updateTitle(message);

            const typingDiv = addMessage('assistant', 'Working', true);
            const statusEl = typingDiv.querySelector('.message-content');

            try {
                const resp = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation_id: parseInt(convId), message: message })
                });

                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let finalResponse = '';
                let currentEvent = '';
                let dataLines = [];

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('event: ')) {
                            currentEvent = line.slice(7);
                            dataLines = [];
                        } else if (line.startsWith('data: ')) {
                            dataLines.push(line.slice(6));
                        } else if (line === '') {
                            // Empty line = end of event
                            const data = dataLines.join('\n');
                            if (currentEvent === 'tool') {
                                statusEl.textContent = 'Using ' + data + '...';
                                scrollToBottom();
                            } else if (currentEvent === 'done') {
                                finalResponse = data;
                            } else if (currentEvent === 'error') {
                                finalResponse = 'Error: ' + data;
                            }
                            dataLines = [];
                        }
                    }
                }

                typingDiv.remove();
                if (finalResponse) {
                    addMessage('assistant', finalResponse);
                    scrollToBottom();
                }
            } catch (err) {
                typingDiv.remove();
                addMessage('assistant', 'Error: ' + err.message);
            }

            msgInput.disabled = false;
            sendBtn.disabled = false;
            msgInput.focus();
        });

        // Auto-grow textarea
        msgInput.addEventListener('input', () => {
            msgInput.style.height = 'auto';
            msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
        });

        // Submit on Enter (Shift+Enter for newline)
        msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                form.dispatchEvent(new Event('submit'));
            }
        });

        // Voice input
        const micBtn = document.getElementById('mic-btn');
        let recognition = null;
        
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'en-GB';
            
            recognition.onstart = () => {
                micBtn.textContent = 'ðŸ”´';
                micBtn.style.background = '#ff4444';
            };
            
            recognition.onend = () => {
                micBtn.textContent = 'ðŸŽ¤';
                micBtn.style.background = '';
            };
            
            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                msgInput.value = transcript;
                msgInput.style.height = 'auto';
                msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
            };
            
            micBtn.addEventListener('click', () => {
                if (micBtn.textContent === 'ðŸ”´') {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });
        } else {
            micBtn.style.display = 'none';
        }

        // Scroll to bottom on load
        scrollToBottom();

        // Render markdown
        function renderMarkdown() {
            document.querySelectorAll('.markdown').forEach(el => {
                if (!el.dataset.rendered) {
                    el.innerHTML = marked.parse(el.textContent);
                    // Remove <p> wrappers inside <li> to reduce whitespace
                    el.querySelectorAll('li > p:first-child').forEach(p => {
                        p.replaceWith(...p.childNodes);
                    });
                    el.dataset.rendered = 'true';
                }
            });
        }
        renderMarkdown();
    </script>
</body>
</html>
{{end}}
